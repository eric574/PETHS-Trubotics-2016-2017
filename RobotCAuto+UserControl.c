#pragma config(Motor,  port1,           ArmR1,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           WristL,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           WristR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RightF,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LeftF,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightB,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           LeftB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           ArmL2and3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           ArmR2and3,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          ArmL1,         tmotorVex393_HBridge, openLoop)

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Pre-autonomous for arm
//Wait 1000x # of milliseconds for each motor function
void auto_armU(int amount){
	motor[port1] = amount;
	//wait1Msec(1000);
	motor[port10] = amount;
	motor[port8] = amount;
	motor[port9] = amount;
	wait1Msec(1000);
}

void auto_armD(int amount){
	motor[port1] = -amount;
	//wait1Msec(1000);
	motor[port10] = -amount;
	motor[port8] = -amount;
	motor[port9] = -amount;
	wait1Msec(1000);
}

//Only call on this if you want to terminate the arm
void auto_arm_stop(){
	motor[port1] = 0;
	motor[port10] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
}

//Pre-autonomous for wrist
void auto_wristUpDown(int amount){
	motor[port2] = amount;
	motor[port3] = amount;
	wait1Msec(1000);
}

// Pre-autonomous for X-Drive
//Wait 1000x # of milliseconds for each motor function
void auto_DriveU(int amount){
	motor[port4] = amount;
	motor[port5] = amount;
	motor[port6] = amount;
	motor[port7] = amount;
	wait1Msec(1000);
}

void auto_DriveD(int amount){
	motor[port4] = -amount;
	motor[port5] = -amount;
	motor[port6] = -amount;
	motor[port7] = -amount;
	wait1Msec(1000);
}

void auto_DriveL(int amount){
	motor[port5] = -amount;
	motor[port7] = amount;
	motor[port4] = amount;
	motor[port6] = -amount;
	wait1Msec(1000);
}

void auto_DriveR(int amount){
	motor[port5] = amount;
	motor[port7] = -amount;
	motor[port4] = -amount;
	motor[port6] = amount;
	wait1Msec(1000);
}

//Only call on this if you want to terminate the drive
void auto_Drive_stop(){
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
}

//Pre-post-autonomous for arm
void armUp(int amount) {
	motor[port1] = amount;
	motor[port10] = amount;
	motor[port8] = amount;
	motor[port9] = amount;
	//wait10Msec(2);
}

void armDown (int amount){
	motor[port1] = -amount;
	motor[port10] = -amount;
	motor[port8] = -amount;
	motor[port9] = -amount;
	//wait10Msec(2);
}

void armStop (){
	motor[port1] = 0;
	motor[port10] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	//wait10Msec(2);
}

//Pre-post-autonomous for wrist
void wristUpDown(int amount){
	//Positive amount is for the claw to close
	//Negative amount is for the claw to open
	motor[port2] = amount;
	motor[port3] = amount;
}

//Pre-post-autonomous for drive
void driveU(int amount){
	motor[port4] = amount;
	motor[port5] = amount;
	motor[port6] = amount;
	motor[port7] = amount;
}

void driveD(int amount){
	motor[port4] = -amount;
	motor[port5] = -amount;
	motor[port6] = -amount;
	motor[port7] = -amount;
}

void driveL(int amount){
	motor[port5] = -amount;
	motor[port7] = amount;
	motor[port4] = amount;
	motor[port6] = -amount;
}

void driveR(int amount){
	motor[port5] = amount;
	motor[port7] = -amount;
	motor[port4] = -amount;
	motor[port6] = amount;
}

void driveStop(){
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
}

//Autonomous function
task autonomous(){
	//Function should only last for approximately 15 seconds
	//Assumes that the robot starts off in starting position
	//Refer to diagram for in-game starting field for autonomous
	//Autonomous code makes the robot knock off the stars on the fence, lift stars, and lift the cube in the centre of the playing field

	auto_armU(127);//Lifts the arm
	auto_arm_stop();
	auto_wristUpDown(-90);//Opens the claw
	auto_DriveD(100);//Drives backwards
	auto_Drive_stop();
	auto_wristUpDown(90);//Closes the claw
	auto_wrist_UpDown(-90);//Opens the claw
	auto_DriveU(100);//Drives upwards
	auto_Drive_stop();
	auto_armD(127);//Lowers the arm
	auto_arm_stop();
	auto_DriveL(90);//Drives to the left
	auto_Drive_stop();
	auto_DriveU(50);//Drives upwards
	auto_Drive_stop();
	auto_wristUpDown(90);//Closes the claw (to grab star)
	auto_DriveR(90);//Drives to the right
	auto_Drive_stop();
	auto_DriveD(100);//Drives backwards
	auto_Drive_stop();
	auto_armU(127);//Lifts the arm
	auto_arm_stop();
	auto_wristUpDown(-90);//Opens the claw (drops the star)
	auto_DriveU(100);//Drives upwards
	auto_Drive_stop();
	auto_armD(127);//Lowers the arm
	auto_arm_stop();
	auto_DriveU(100);//Drives upwards
	auto_Drive_stop();
	auto_DriveR(90);//Drives to the right
	auto_Drive_stop();
	auto_DriveU(80);//Drives upwards	
	auto_Drive_stop();
	auto_wristUpDown(90);//Closes the claw (grabs the star in the corner)
	auto_DriveL(90);//Drives to the left 
	auto_Drive_stop();
	auto_DriveD(100);//Drives backwards
	auto_Drive_stop();
	auto_armU(127);//Lifts the arm
	auto_arm_stop();
	auto_wristUpDown(-90);//Opens the claw (drops the star)
	auto_DriveU(100);//Drives upwards
	auto_Drive_stop();
	auto_armD(127);//Lowers the arm
	auto_arm_stop();
	auto_DriveU(90);//Drives upwards
	auto_Drive_stop();
	auto_DriveL(90);//Drives to the left (hopefully, towards the centre of the playing  field)
	auto_Drive_stop();
	auto_DriveU(50);//Drives upwards
	auto_Drive_stop();
	auto_wristUpDown(90);//Closes the claw (grabs the cube)
	auto_DriveR(90);//Drives to the right
	auto_Drive_stop();
	auto_DriveD(100);//Drives backwards
	auto_Drive_stop();
	auto_armU(127);//Lifts the arm
	auto_arm_stop();
	auto_wristUpDown(-90);//Opens the claw (drops the cube)
	auto_DriveU(80);//Drives upwards
	auto_Drive_stop();
	auto_DriveR(180);//Drives to the right 180 degrees (faces the fence)
	auto_Drive_stop();
	auto_DriveU(100);//Drives upwards
	auto_Drive_stop();
	auto_wristUpDown(-90);//Opens the claw (hopefully, to knock off the stars)
	auto_wristUpDown(90);//Closes the claw (hopefully, to knock off the stars)
	auto_wristUpDown(-90);//Re-opens the claw (again, hopefully to knock off the stars)

/*
	auto_armD(127);
	auto_arm_stop();
	auto_DriveU(80);
	auto_Drive_stop();
	auto_DriveL(100);
	auto_Drive_stop();
	auto_DriveR(80);
	auto_Drive_stop();
	auto_DriveU(50);
	auto_Drive_stop();
	auto_wristUpDown(80);
	auto_DriveD(100);
	auto_Drive_stop();
	auto_armU(127);
	auto_arm_stop();
	auto_wristUpDown(-80);
	auto_DriveU(80);
	auto_Drive_stop();
	auto_armD(127);
	auto_arm_stop();
	auto_DriveU(100);
	auto_Drive_stop();
	auto_DriveR(180);
	auto_Drive_stop();
	auto_DriveU(80);
	auto_Drive_stop();
	auto_DriveL(80);
	auto_Drive_stop();
	auto_DriveU(50);
	auto_Drive_stop();
	auto_wristUpDown(80);
	auto_DriveR(50);
	auto_Drive_stop();
	auto_DriveD(100);
	auto_Drive_stop();
	auto_armU(127);
	auto_arm_stop();
	auto_wristUpDown(-80);
	auto_DriveU(80);
	auto_Drive_stop();
	auto_armD(127);
	auto_arm_stop();
	auto_DriveU(50);
	auto_Drive_stop();
	auto_DriveR(100);
	auto_Drive_stop();
	auto_DriveL(80);
	auto_Drive_stop();
	auto_DriveD(100);
	auto_Drive_stop();
	auto_armU(127);
	auto_wristUpDown(-80);
	auto_DriveU(80);
	auto_Drive_stop();
	auto_armD(127);
	auto_arm_stop();
	auto_DriveL(80);
	auto_Drive_stop();
	auto_DriveU(100);
	auto_Drive_stop();
	auto_DriveR(80);
	auto_Drive_stop();
	auto_armU(127);
	auto_wristUpDown(-80);
	auto_DriveU(80);
	auto_Drive_stop();
	auto_DriveD(100);
	auto_Drive_stop();
	auto_armD(127);
	auto_arm_stop();
	auto_DriveR(180);
	auto_Drive_stop();
	auto_DriveU(80);
	auto_Drive_stop();
	auto_wristUpDown(80);
	auto_DriveD(100);	
	auto_Drive_stop();
	auto_armU(127);
	auto_arm_stop();
	auto_wristUpDown(-80);
	auto_DriveU(80);
	auto_Drive_stop();
	auto_armD(127);
	auto_arm_stop();
	auto_DriveL(180);
	auto_Drive_stop();
	auto_armU(127);
	auto_arm_stop();
	auto_DriveU(100);
	auto_Drive_stop();
	//End of function
*/ 
//Code is extraneously long (Period is only 15 secs)
}

task post_autonomous(){
	//Declaration of variables (12 in total)
	int joy1;
	int joy2;
	int joy3;
	int joy4;
	int b6u;
	int b6d;
	int b5u;
	int b5d;
	int b7u;
	int b7r;
	int b7d;
	int b7l;

	//Post-autonomous period (manual control)
	while(true){
		joy1 = vexRT[Ch1];
		joy2 = vexRT[Ch2];
		joy3 = vexRT[Ch3];
		joy4 = vexRT[Ch4];
		b6u = vexRT[Btn6U];
		b6d = vexRT[Btn6D];
		b5u = vexRT[Btn5U];
		b5d = vexRT[Btn5D];

		b7u = vexRT[Btn7U];
		b7r = vexRT[Btn7R];
		b7d = vexRT[Btn7D];
		b7l = vexRT[Btn7L];

		if(joy1){
			driveU(100); //Drive forward
		}
		else if (joy2){
			driveD(100); //Drive backward
		}
		else if (joy3){
			driveL(100); //Drive left
		}
		else if (joy4){
			driveR(100); //Drive right
		}
		/*else if{
		//70% due to too high sensitivity
		motor[port1] = ((-1*joy3) + joy1 - joy4)*0.70;
		motor[port2] = ((-1*joy3) - joy1 + joy4)*0.70;
		motor[port3] = ((-1*joy3) + joy1 + joy4)*0.70;
		motor[port4] = ((-1*joy3) - joy1 - joy4)*0.70;
		}
		*/
		else {
			driveStop();
		}

		if (b5u){
			wristUpDown(-90); //Opens the claw
		}
		else if (b5d){
			wristUpDown(90); //Closes the claw
		}
		else {
			wristUpDown(0);
		}

		if (b6u){
			armUp(127); //Lifts the arm
		}
		else if (b6d){
			armDown(127); //Lowers the arm
		}
		else {
			armStop();
		}
	}
}

task main(){
	//Pre-autonomous period(press button to start)

	if (vexRT[Btn6U]==1){ //If Btn6U is pressed, task autonomous() starts
		startTask(autonomous);
	}
	else{
		//Post-autonomous period(wait 15 seconds due to autonomous period)
		wait1Msec(15000); //Wait 15 seconds for autonomous to finish
		startTask(post_autonomous); //Start task post_autonomous()
	}
}
